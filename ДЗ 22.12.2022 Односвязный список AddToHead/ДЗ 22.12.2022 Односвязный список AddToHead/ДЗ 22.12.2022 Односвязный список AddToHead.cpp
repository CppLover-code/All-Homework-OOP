/*
	В класс односвязного списка (см. код в Тимс)
	добавить метод, добавляющий элемент к началу (голове) списка.
*/
#include <iostream>
using namespace std;
struct Element
{
    char data;                          // Данные    
    Element* Next;                      // Адрес следующего элемента списка
};

class List                              // Односвязный список
{
    Element* Head;                      // Адрес головного элемента списка
    Element* Tail;                      // Адрес концевого элемента списка
    int Count;                          // Количество элементов списка
public:
    
    List();                             // Конструктор  
    ~List();                            // Деструктор
    void Add(char data);                // Добавление элемента в список (Новый элемент становится последним)
    void AddToHead(char data);          // Добавление элемента в список (Новый элемент становится первым)
    void Del();                         // Удаление элемента списка (Удаляется головной элемент)
    void DelAll();                      // Удаление всего списка
    void Print();                       // Вывод содержимого списка (Распечатка начинается с головного элемента)
    void PrintHead();                   // Вывод головы списка
    void PrintTail();                   // Вывод хвоста списка
    void Print(int pos);                // Вывод данных в позиции pos
    int GetCount();                     // Получение количества элементов, находящихся в списке
};
List::List()
{
    Head = Tail = nullptr;              // Изначально список пуст
    Count = 0;
}
List::~List()
{
    DelAll();                           // Вызов функции удаления
}
int List::GetCount()
{
    return Count;                       // Возвращаем количество элементов
}
void List::Add(char data)
{    
    Element* temp = new Element;        // создание нового элемента
    
    temp->data = data;                  // заполнение данными
    
    temp->Next = nullptr;               // следующий элемент отсутствует
    
    if (Head != nullptr)                // новый элемент становится последним элементом списка
    {                                   // если он не первый добавленный
        Tail->Next = temp;
        Tail = temp;
    }
    else                                // новый элемент становится единственным
    {                                   // если он первый добавленный
        Head = Tail = temp;
    }
    Count++;
}
void List::AddToHead(char data)
{
    Element* temp = new Element;        // создание нового элемента

    temp->data = data;                  // заполнение данными

    temp->Next = Head;                  // новый элемент будет содержать адрес текущего Head

    if (Head != nullptr)                // новый элемент становится первым элементом списка
    {                                   // если он не первый добавленный
        Head = temp;                    // теперь Head содержит адрес нового добавленного элемента, а Tail не меняется
    }
    else                                // новый элемент становится единственным
    {                                   // если он первый добавленный
        Head = Tail = temp;
    }
    Count++;
}
void List::Del()
{ 
    Element* temp = Head;               // запоминаем адрес головного элемента 
    Head = Head->Next;                  // перебрасываем голову на следующий элемент

    delete temp;                        // удаляем бывший головной элемент
    Count--;
}
void List::DelAll()
{   
    while (Head != 0)                   // Пока еще есть элементы        
        Del();                          // Удаляем элементы по одному

    //Count = 0;
}
void List::Print()
{ 
    Element* temp = Head;               // Запоминаем адрес головного элемента
    
    while (temp != 0)                   // Пока еще есть элементы
    {
       
        cout << temp->data << " ";      // Выводим данные
       
        temp = temp->Next;              // Переходим на следующий элемент
    }
    cout << "\n\n";
}
void List::PrintHead()
{
    cout << Head->data << "\n\n";       // Выводим данные
}
void List::PrintTail()
{
    cout << Tail->data << "\n\n";       // Выводим данные
}
void List::Print(int pos)
{
    Element* temp = Head;               // Запоминаем адрес головного элемента (это уже первый элемент)
    int p = 1;                          // переменная-счётчик

    while (p < pos)                     // Пока счётчик не равен позиции элемента
    {       
        temp = temp->Next;              // Переходим на следующий элемент
        p++;                            // Увеличиваем счетчик
    }
 
    cout << temp->data << " ";          // Выводим данные
    cout << "\n\n";
}

void main()
{    
    List lst;                           // Создаем объект класса List
    char s[] = "Hello, World !!!";      // Тестовая строка

    cout << s << "\n\n";                // Выводим строку
    
    int len = strlen(s);                // Определяем длину строки
    
    for (int i = 0; i < len; i++)       // Загоняем строку в список
        lst.Add(s[i]);
    
    lst.Print();                        // Распечатываем содержимое списка
    
    lst.Del();                          // Удаляем три элемента списка
    lst.Del();
    lst.Del();
    
    lst.Print();                        // Распечатываем содержимое списка
    cout << lst.GetCount() << endl;     // Получаем кол-во элементов
     
    lst.PrintHead();                    // Выводим данные головы
    lst.PrintTail();                    // Выводим данные хвоста
    lst.Print(5);                       // Выводим данные элемента в позиции

    char s1[] = "leH";                  // Тестовая строка
    int len1 = strlen(s1);              // Определяем длину строки
    for (int i = 0; i < len1; i++)      // Загоняем строку в начало списка
        lst.AddToHead(s1[i]);
    lst.Print();                        // Распечатываем содержимое списка
}

// Односвязный список — это совокупность нескольких объектов, каждый из которых представляет собой элемент 
// списка, состоящий из двух частей. Первая часть элемента — значение, которое он хранит, вторая — информация
// о следующем элементе списка.